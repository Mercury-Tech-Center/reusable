name: Multi-Region ECS Deploy

on:
  workflow_call:
    inputs:
      branch-name:
        required: true
        type: string
      repository-name:
        required: true
        type: string
      brand-name:
        required: true
        type: string
      auto-deploy-regions:
        required: false
        type: string
        default: "eu-central-1"
        description: "Regions that deploy automatically"
      manual-deploy-regions:
        required: false
        type: string
        default: ""
        description: "Regions that require manual approval"
      slack-channel:
        required: false
        type: string
        default: "#deployments"
        description: "Slack channel for notifications"
      slack-team:
        required: false
        type: string
        description: "Team name for notification context"
      slack-critical-tag:
        required: false
        type: string
        default: "@here"
        description: "Tag for critical notifications"
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      NPM_TOKEN:
        required: false
      NPM_REGISTRY:
        required: false
      SLACK_WEBHOOK_URL:
        required: false
        description: "Slack webhook URL for notifications"

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image-uri: ${{ steps.build.outputs.image-uri }}
      auto-regions: ${{ steps.parse-regions.outputs.auto_regions }}
      manual-regions: ${{ steps.parse-regions.outputs.manual_regions }}
      env: ${{ steps.set-env.outputs.env }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Parse region configuration
        id: parse-regions
        run: |
          # Set regions directly from inputs
          echo "auto_regions=${{ inputs.auto-deploy-regions }}" >> $GITHUB_OUTPUT
          echo "manual_regions=${{ inputs.manual-deploy-regions }}" >> $GITHUB_OUTPUT

          # Debug: show what we're setting
          echo "Setting auto_regions to: ${{ inputs.auto-deploy-regions }}"
          echo "Setting manual_regions to: ${{ inputs.manual-deploy-regions }}"

      - name: Set environment variables dynamically
        id: set-env
        run: |
          BRANCH_NAME="${{ inputs.branch-name }}"
          REPOSITORY_NAME="${{ inputs.repository-name }}"
          BRAND_NAME="${{ inputs.brand-name }}"
          case "$BRANCH_NAME" in
            "dev")
              ENV="dev"
              CLUSTER_SUFFIX="dev"
              ;;
            "staging")
              ENV="staging"
              CLUSTER_SUFFIX="staging"
              ;;
            "prod")
              ENV="prod"
              CLUSTER_SUFFIX="prod"
              ;;
            *)
              echo "Unknown branch name: $BRANCH_NAME"
              exit 1
              ;;
          esac
          CLUSTER_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-cluster"
          SERVICE_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-${REPOSITORY_NAME}"

          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "env=$ENV" >> $GITHUB_OUTPUT
          echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT

      - name: Debug region parsing
        run: |
          echo "Input auto-deploy-regions: ${{ inputs.auto-deploy-regions }}"
          echo "Input manual-deploy-regions: ${{ inputs.manual-deploy-regions }}"
          echo "Parsed auto_regions: ${{ steps.parse-regions.outputs.auto_regions }}"
          echo "Parsed manual_regions: ${{ steps.parse-regions.outputs.manual_regions }}"

      - name: Debug inputs and outputs
        run: |
          echo "Repository: ${{ inputs.repository-name }}"
          echo "Branch: ${{ inputs.branch-name }}"
          echo "Team: ${{ inputs.slack-team }}"
          echo "Slack Channel: ${{ inputs.slack-channel }}"

      - name: Notify deployment started
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"ðŸš€ *Deployment Started*\nâ€¢ Repository: \`${{ inputs.repository-name }}\`\nâ€¢ Branch: \`${{ inputs.branch-name }}\`\nâ€¢ Team: ${{ inputs.slack-team }}\nâ€¢ Auto Regions: \`${{ steps.parse-regions.outputs.auto_regions }}\`\nâ€¢ Manual Regions: \`${{ steps.parse-regions.outputs.manual_regions }}\`\"
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push Docker image to Amazon ECR
        id: build
        run: |
          docker build -t ${{ steps.login-ecr.outputs.registry }}/${SERVICE_NAME}:latest \
            --build-arg NPM_REGISTRY=${{ secrets.NPM_REGISTRY }} \
            --build-arg NPM_TOKEN=${{ secrets.NPM_TOKEN }} .
          docker push ${{ steps.login-ecr.outputs.registry }}/${SERVICE_NAME}:latest
          echo "image-uri=${{ steps.login-ecr.outputs.registry }}/${SERVICE_NAME}:latest" >> $GITHUB_OUTPUT

  deploy-auto-regions:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Push image to auto regions and deploy
        run: |
          # Get the source region (where we built the image)
          SOURCE_REGION="${{ secrets.AWS_REGION }}"

          IFS=',' read -ra REGIONS <<< "${{ needs.build.outputs.auto_regions }}"
          for region in "${REGIONS[@]}"; do
            echo "Processing region: $region"
            
            if [ "$region" != "$SOURCE_REGION" ]; then
              echo "Pushing image to $region"
              
              # Login to ECR in this region
              aws ecr get-login-password --region $region | docker login --username AWS --password-stdin ${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-${{ inputs.repository-name }}.${{ needs.build.outputs.env }}.dkr.ecr.$region.amazonaws.com
              
              # Tag and push to this region
              SOURCE_IMAGE="${{ needs.build.outputs.image-uri }}"
              TARGET_REGISTRY="${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-${{ inputs.repository-name }}.${{ needs.build.outputs.env }}.dkr.ecr.$region.amazonaws.com"
              
              docker tag $SOURCE_IMAGE $TARGET_REGISTRY:latest
              docker push $TARGET_REGISTRY:latest
              echo "âœ… Image pushed to $region"
            else
              echo "âœ… Image already exists in $region (source region)"
            fi
            
            echo "Deploying to $region"
            aws ecs update-service \
              --cluster ${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-cluster \
              --service ${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-${{ inputs.repository-name }} \
              --region $region \
              --force-new-deployment
            
            # Notify success for this region
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"âœ… *Auto-Deployment Success*\nâ€¢ Region: \`$region\`\nâ€¢ Cluster: \`${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-cluster\`\nâ€¢ Status: Deployed automatically\"
              }" \
              ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
          done

  deploy-manual-regions:
    needs: [build, deploy-auto-regions]
    runs-on: ubuntu-latest
    if: contains(needs.build.outputs.manual-regions, ',') || (needs.build.outputs.manual-regions != '' && needs.build.outputs.manual_regions != 'null')
    environment: manual-approval
    steps:
      - name: Wait for manual approval
        run: echo "Waiting for approval to deploy to manual regions"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Push image to manual regions and deploy
        run: |
          # Get the source region (where we built the image)
          SOURCE_REGION="${{ secrets.AWS_REGION }}"

          IFS=',' read -ra REGIONS <<< "${{ needs.build.outputs.manual_regions }}"
          for region in "${REGIONS[@]}"; do
            echo "Processing manual region: $region"
            
            if [ "$region" != "$SOURCE_REGION" ]; then
              echo "Pushing image to $region"
              
              # Login to ECR in this region
              aws ecr get-login-password --region $region | docker login --username AWS --password-stdin ${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-${{ inputs.repository-name }}.${{ needs.build.outputs.env }}.dkr.ecr.$region.amazonaws.com
              
              # Tag and push to this region - use the image from build job
              SOURCE_IMAGE="${{ needs.build.outputs.image-uri }}"
              TARGET_REGISTRY="${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-${{ inputs.repository-name }}.${{ needs.build.outputs.env }}.dkr.ecr.$region.amazonaws.com"
              
              docker tag $SOURCE_IMAGE $TARGET_REGISTRY:latest
              docker push $TARGET_REGISTRY:latest
              echo "âœ… Image pushed to $region"
            else
              echo "âœ… Image already exists in $region (source region)"
            fi
            
            echo "Deploying to $region"
            aws ecs update-service \
              --cluster ${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-cluster \
              --service ${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-${{ inputs.repository-name }} \
              --region $region \
              --force-new-deployment
            
            # Notify success for this region
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"âœ… *Deployment Success*\nâ€¢ Region: \`$region\`\nâ€¢ Cluster: \`${{ needs.build.outputs.env }}-${{ inputs.brand-name }}-cluster\`\nâ€¢ Status: Successfully deployed\"
              }" \
              ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
          done

  notify-approval-required:
    needs: build
    runs-on: ubuntu-latest
    if: contains(needs.build.outputs.manual-regions, ',') || (needs.build.outputs.manual-regions != '' && needs.build.outputs.manual_regions != 'null')
    steps:
      - name: Notify manual approval required
        run: |
          IFS=',' read -ra REGIONS <<< "${{ needs.build.outputs.manual_regions }}"
          for region in "${REGIONS[@]}"; do
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"â³ *Manual Approval Required*\nâ€¢ Region: \`$region\`\nâ€¢ Team: ${{ inputs.slack-team }}\nâ€¢ Deployment is waiting for manual approval in $region\nâ€¢ <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Click to review and approve>\"
              }" \
              ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
          done

  deployment-summary:
    needs: [build, deploy-auto-regions, deploy-manual-regions]
    runs-on: ubuntu-latest
    if: always()
    outputs:
      summary: ${{ steps.generate-summary.outputs.summary }}
    steps:
      - name: Generate deployment summary
        id: generate-summary
        run: |
          SUMMARY="*Deployment Summary for ${{ inputs.repository-name }}*\n"
          SUMMARY+="â€¢ Branch: \`${{ inputs.branch-name }}\`\n"
          SUMMARY+="â€¢ Team: ${{ inputs.slack-team }}\n"
          SUMMARY+="â€¢ Environment: ${{ needs.build.outputs.env }}\n\n"

          # Add auto-deployment results
          if [ -n "${{ needs.build.outputs.auto_regions }}" ]; then
            SUMMARY+="*Auto-Deployed Regions:*\n"
            IFS=',' read -ra AUTO_REGIONS <<< "${{ needs.build.outputs.auto_regions }}"
            for region in "${AUTO_REGIONS[@]}"; do
              SUMMARY+="â€¢ âœ… \`$region\` - Deployed automatically\n"
            done
            SUMMARY+="\n"
          fi

          # Add manual deployment results
          if [ -n "${{ needs.build.outputs.manual_regions }}" ]; then
            SUMMARY+="*Manual Approval Regions:*\n"
            IFS=',' read -ra MANUAL_REGIONS <<< "${{ needs.build.outputs.manual_regions }}"
            for region in "${MANUAL_REGIONS[@]}"; do
              SUMMARY+="â€¢ â³ \`$region\` - Requires manual approval\n"
            done
          fi

          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Notify deployment summary
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"ðŸ“Š *Deployment Summary*\n${{ steps.generate-summary.outputs.summary }}\"
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
