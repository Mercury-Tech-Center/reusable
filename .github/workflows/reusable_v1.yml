name: Multi-Region ECS Deploy

on:
  workflow_call:
    inputs:
      branch-name:
        required: true
        type: string
      repository-name:
        required: true
        type: string
      brand-name:
        required: true
        type: string
      auto-deploy-regions:
        required: false
        type: string
        default: "eu-central-1"
        description: "Regions that deploy automatically"
      manual-deploy-regions:
        required: false
        type: string
        default: ""
        description: "Regions that require manual approval"
      slack-channel:
        required: false
        type: string
        default: "#deployments"
        description: "Slack channel for notifications"
      slack-team:
        required: false
        type: string
        description: "Team name for notification context"
      slack-critical-tag:
        required: false
        type: string
        default: "@here"
        description: "Tag for critical notifications"
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      NPM_TOKEN:
        required: false
      NPM_REGISTRY:
        required: false
      SLACK_WEBHOOK_URL:
        required: false
        description: "Slack webhook URL for notifications"

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      auto-regions: ${{ env.AUTO_REGIONS }}
      manual-regions: ${{ env.MANUAL_REGIONS }}
      env: ${{ steps.set-env.outputs.env }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Debug inputs received
        run: |
          echo "=== INPUT DEBUG ==="
          echo "branch-name: '${{ inputs.branch-name }}'"
          echo "repository-name: '${{ inputs.repository-name }}'"
          echo "brand-name: '${{ inputs.brand-name }}'"
          echo "auto-deploy-regions: '${{ inputs.auto-deploy-regions }}'"
          echo "manual-deploy-regions: '${{ inputs.manual-deploy-regions }}'"
          echo "=================="

      - name: Set environment variables dynamically
        id: set-env
        run: |
          BRANCH_NAME="${{ inputs.branch-name }}"
          REPOSITORY_NAME="${{ inputs.repository-name }}"
          BRAND_NAME="${{ inputs.brand-name }}"
          case "$BRANCH_NAME" in
            "dev")
              ENV="dev"
              CLUSTER_SUFFIX="dev"
              ;;
            "staging")
              ENV="staging"
              CLUSTER_SUFFIX="staging"
              ;;
            "prod")
              ENV="prod"
              CLUSTER_SUFFIX="prod"
              ;;
            *)
              echo "Unknown branch name: $BRANCH_NAME"
              exit 1
              ;;
          esac
          CLUSTER_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-cluster"
          SERVICE_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-${REPOSITORY_NAME}"

          # Set regions as environment variables
          AUTO_REGIONS="${{ inputs.auto-deploy-regions }}"
          MANUAL_REGIONS="${{ inputs.manual-deploy-regions }}"

          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "AUTO_REGIONS=$AUTO_REGIONS" >> $GITHUB_ENV
          echo "MANUAL_REGIONS=$MANUAL_REGIONS" >> $GITHUB_ENV
          echo "env=$ENV" >> $GITHUB_OUTPUT
          echo "service-name=$SERVICE_NAME" >> $GITHUB_OUTPUT

          # Debug: show what we set
          echo "=== ENVIRONMENT VARIABLES SET ==="
          echo "AUTO_REGIONS: $AUTO_REGIONS"
          echo "MANUAL_REGIONS: $MANUAL_REGIONS"
          echo "================================"

          # Debug: show what's in GITHUB_ENV
          echo "=== GITHUB_ENV CONTENTS ==="
          cat $GITHUB_ENV
          echo "==========================="

      - name: Debug region parsing
        run: |
          echo "Input auto-deploy-regions: ${{ inputs.auto-deploy-regions }}"
          echo "Input manual-deploy-regions: ${{ inputs.manual-deploy-regions }}"
          echo "Parsed auto_regions: ${{ steps.parse-regions.outputs.auto_regions }}"
          echo "Parsed manual_regions: ${{ steps.parse-regions.outputs.manual_regions }}"

      - name: Debug inputs and outputs
        run: |
          echo "Repository: ${{ inputs.repository-name }}"
          echo "Branch: ${{ inputs.branch-name }}"
          echo "Team: ${{ inputs.slack-team }}"
          echo "Slack Channel: ${{ inputs.slack-channel }}"

      - name: Notify deployment started
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"ðŸš€ *Deployment Started*\nâ€¢ Repository: \`${{ inputs.repository-name }}\`\nâ€¢ Branch: \`${{ inputs.branch-name }}\`\nâ€¢ Team: ${{ inputs.slack-team }}\nâ€¢ Auto Regions: \`${{ steps.parse-regions.outputs.auto_regions }}\`\nâ€¢ Manual Regions: \`${{ steps.parse-regions.outputs.manual_regions }}\`\"
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"

  deploy-auto-regions:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variables
        run: |
          BRANCH_NAME="${{ inputs.branch-name }}"
          REPOSITORY_NAME="${{ inputs.repository-name }}"
          BRAND_NAME="${{ inputs.brand-name }}"
          case "$BRANCH_NAME" in
            "dev")
              ENV="dev"
              CLUSTER_SUFFIX="dev"
              ;;
            "staging")
              ENV="staging"
              CLUSTER_SUFFIX="staging"
              ;;
            "prod")
              ENV="prod"
              CLUSTER_SUFFIX="prod"
              ;;
            *)
              echo "Unknown branch name: $BRANCH_NAME"
              exit 1
              ;;
          esac
          CLUSTER_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-cluster"
          SERVICE_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-${REPOSITORY_NAME}"

          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Debug ECR registry
        run: |
          echo "=== ECR DEBUG ==="
          echo "ECR Registry from login step: '${{ steps.login-ecr.outputs.registry }}'"
          echo "ECR Registry length: $(echo '${{ steps.login-ecr.outputs.registry }}' | wc -c)"
          echo "=================="

      - name: Build, push and deploy to auto regions
        run: |
          echo "=== DEBUG INFO ==="
          echo "Auto regions from inputs: '${{ inputs.auto-deploy-regions }}'"
          echo "Auto regions length: $(echo '${{ inputs.auto-deploy-regions }}' | wc -c)"
          echo "=================="

          IFS=',' read -ra REGIONS <<< "${{ inputs.auto-deploy-regions }}"
          echo "Parsed regions array length: ${#REGIONS[@]}"
          echo "Regions array: ${REGIONS[*]}"

          for region in "${REGIONS[@]}"; do
            echo "Processing auto region: $region"
            
            # Login to ECR for this specific region
            echo "Logging into ECR for region: $region"
            aws ecr get-login-password --region $region | docker login --username AWS --password-stdin $region.dkr.ecr.$region.amazonaws.com
            
            # Build image for this region
            echo "Building Docker image for $region"
            
            # Use the same pattern as latest_reusable.yml
            SERVICE_NAME="${{ inputs.branch-name }}-${{ inputs.brand-name }}-${{ inputs.repository-name }}"
            IMAGE_URI="$region.dkr.ecr.$region.amazonaws.com/${SERVICE_NAME}:latest"
            
            docker build -t $IMAGE_URI \
              --build-arg NPM_REGISTRY=${{ secrets.NPM_REGISTRY }} \
              --build-arg NPM_TOKEN=${{ secrets.NPM_TOKEN }} .
            
            # Push to this region
            echo "Pushing image to $region"
            docker push $IMAGE_URI
            
            # Deploy to this region
            echo "Deploying to $region"
            aws ecs update-service \
              --cluster $CLUSTER_NAME \
              --service $SERVICE_NAME \
              --region $region \
              --force-new-deployment
            
            # Notify success for this region
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"âœ… *Auto-Deployment Success*\nâ€¢ Region: \`$region\`\nâ€¢ Cluster: \`$CLUSTER_NAME\`\nâ€¢ Status: Deployed automatically\"
              }" \
              ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
          done

  deploy-manual-regions:
    needs: build
    runs-on: ubuntu-latest
    if: contains(needs.build.outputs.manual-regions, ',') || (needs.build.outputs.manual-regions != '' && needs.build.outputs.manual_regions != 'null')
    environment: manual-approval
    steps:
      - name: Wait for manual approval
        run: echo "Waiting for approval to deploy to manual regions"

      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set environment variables
        run: |
          BRANCH_NAME="${{ inputs.branch-name }}"
          REPOSITORY_NAME="${{ inputs.repository-name }}"
          BRAND_NAME="${{ inputs.brand-name }}"
          case "$BRANCH_NAME" in
            "dev")
              ENV="dev"
              CLUSTER_SUFFIX="dev"
              ;;
            "staging")
              ENV="staging"
              CLUSTER_SUFFIX="staging"
              ;;
            "prod")
              ENV="prod"
              CLUSTER_SUFFIX="prod"
              ;;
            *)
              echo "Unknown branch name: $BRANCH_NAME"
              exit 1
              ;;
          esac
          CLUSTER_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-cluster"
          SERVICE_NAME="${CLUSTER_SUFFIX}-${BRAND_NAME}-${REPOSITORY_NAME}"

          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, push and deploy to manual regions
        run: |
          echo "=== DEBUG INFO ==="
          echo "Manual regions from inputs: '${{ inputs.manual-deploy-regions }}'"
          echo "Manual regions length: $(echo '${{ inputs.manual-deploy-regions }}' | wc -c)"
          echo "=================="

          IFS=',' read -ra REGIONS <<< "${{ inputs.manual-deploy-regions }}"
          echo "Parsed regions array length: ${#REGIONS[@]}"
          echo "Regions array: ${REGIONS[*]}"

          for region in "${REGIONS[@]}"; do
            echo "Processing manual region: $region"
            
            # Login to ECR for this specific region
            echo "Logging into ECR for region: $region"
            aws ecr get-login-password --region $region | docker login --username AWS --password-stdin $region.dkr.ecr.$region.amazonaws.com
            
            # Build image for this region
            echo "Building Docker image for $region"
            
            # Use the same pattern as latest_reusable.yml
            SERVICE_NAME="${{ inputs.branch-name }}-${{ inputs.brand-name }}-${{ inputs.repository-name }}"
            IMAGE_URI="$region.dkr.ecr.$region.amazonaws.com/${SERVICE_NAME}:latest"
            
            docker build -t $IMAGE_URI \
              --build-arg NPM_REGISTRY=${{ secrets.NPM_REGISTRY }} \
              --build-arg NPM_TOKEN=${{ secrets.NPM_TOKEN }} .
            
            # Push to this region
            echo "Pushing image to $region"
            docker push $IMAGE_URI
            
            # Deploy to this region
            echo "Deploying to $region"
            aws ecs update-service \
              --cluster $CLUSTER_NAME \
              --service $SERVICE_NAME \
              --region $region \
              --force-new-deployment
            
            # Notify success for this region
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"âœ… *Deployment Success*\nâ€¢ Region: \`$region\`\nâ€¢ Cluster: \`$CLUSTER_NAME\`\nâ€¢ Status: Successfully deployed\"
              }" \
              ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
          done

  notify-approval-required:
    needs: build
    runs-on: ubuntu-latest
    if: contains(needs.build.outputs.manual-regions, ',') || (needs.build.outputs.manual-regions != '' && needs.build.outputs.manual_regions != 'null')
    steps:
      - name: Notify manual approval required
        run: |
          IFS=',' read -ra REGIONS <<< "${{ needs.build.outputs.manual_regions }}"
          for region in "${REGIONS[@]}"; do
            curl -X POST -H 'Content-type: application/json' \
              --data "{
                \"text\": \"â³ *Manual Approval Required*\nâ€¢ Region: \`$region\`\nâ€¢ Team: ${{ inputs.slack-team }}\nâ€¢ Deployment is waiting for manual approval in $region\nâ€¢ <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Click to review and approve>\"
              }" \
              ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
          done

  deployment-summary:
    needs: [build, deploy-auto-regions, deploy-manual-regions]
    runs-on: ubuntu-latest
    if: always()
    outputs:
      summary: ${{ steps.generate-summary.outputs.summary }}
    steps:
      - name: Generate deployment summary
        id: generate-summary
        run: |
          SUMMARY="*Deployment Summary for ${{ inputs.repository-name }}*\n"
          SUMMARY+="â€¢ Branch: \`${{ inputs.branch-name }}\`\n"
          SUMMARY+="â€¢ Team: ${{ inputs.slack-team }}\n"
          SUMMARY+="â€¢ Environment: ${{ needs.build.outputs.env }}\n\n"

          # Add auto-deployment results
          if [ -n "${{ needs.build.outputs.auto_regions }}" ]; then
            SUMMARY+="*Auto-Deployed Regions:*\n"
            IFS=',' read -ra AUTO_REGIONS <<< "${{ needs.build.outputs.auto_regions }}"
            for region in "${AUTO_REGIONS[@]}"; do
              SUMMARY+="â€¢ âœ… \`$region\` - Deployed automatically\n"
            done
            SUMMARY+="\n"
          fi

          # Add manual deployment results
          if [ -n "${{ needs.build.outputs.manual_regions }}" ]; then
            SUMMARY+="*Manual Approval Regions:*\n"
            IFS=',' read -ra MANUAL_REGIONS <<< "${{ needs.build.outputs.manual_regions }}"
            for region in "${MANUAL_REGIONS[@]}"; do
              SUMMARY+="â€¢ â³ \`$region\` - Requires manual approval\n"
            done
          fi

          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

      - name: Notify deployment summary
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"ðŸ“Š *Deployment Summary*\n${{ steps.generate-summary.outputs.summary }}\"
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }} || echo "Slack notification failed"
